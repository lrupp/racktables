#!/bin/sh

# This file is a part of RackTables, a datacenter and server room management
# framework. See accompanying file "COPYING" for the full copyright and
# licensing information.

# This script implements a simple (one file at a time) one-way feed into a git
# repository. To make a commit it takes the following PHP code:
#
# $params = array
# (
#   'u' => 'racktables_pseudo_user',
#   'r' => '/path/to/repository',
#   'f' => 'path/to/file/within/the/repository/file.txt',
#   'm' => 'commit message text',
#   'a' => 'Some Author <user@example.org>',
# );
# $rc = callScript ('git-commit', $params, $file_contents, $stdout, $stderr);
#
# The meaning of $stdout and $stderr is the same as in queryTerminal().
#
# This script uses sudo to switch between the pseudo-users and requires an
# entry in sudoers along the following lines:
# httpduser ALL=(racktablesuser) NOPASSWD:/path/to/racktables/gateways/git-commit

THISFILE=`basename "$0"`

usage_and_exit()
{
	cat >&2 <<ENDOFMESSAGE
Usage: $THISFILE -u <u> -r <r> -f <f> [-m <m> -a <a>]
  -u <username>    A pseudo-user to work as (this script will try to sudo
                     itself if the current user is not the same). The user
                     must be able to write to the repository filesystem and to
                     run "git pull", "git commit" and "git push" without any
                     user interaction (i.e. the git remote must be on a local
                     filesystem or be configured to use SSH keys).
  -r <repodir>     An absolute path to an existing git repository.
  -f <filepath>    A relative path to a file within the repository (if the
                     file or the path do not exist, the missing component(s)
                     will be created automatically).
  -m <msg>         An optional custom commit message instead of the default
                     one. The message may be a multi-line string, in which
                     case it should follow the format recommended in the
                     "discussion" section of the git-commit(1) man page.
  -a <author>      An optional git commit author instead of the default or the
                     one previously configured with git-config(1).
ENDOFMESSAGE
	exit 1
}

assert_nonempty_option()
{
	if [ -z "$2" ]; then
		echo "$THISFILE: missing option $1" >&2
		usage_and_exit
	fi
}

git_pull_or_exit()
{
	git pull --quiet || {
		echo "$THISFILE: failed to run 'git pull' (rc=$?)" >&2
		exit 2
	}
}

git_push_or_exit()
{
	git push --quiet || {
		echo "$THISFILE: failed to run 'git push' (rc=$?)" >&2
		exit 5
	}
}

git_commit_or_exit()
{
	# git processes the path to the file automatically, but the shell
	# redirection obviously does not.
	DIRNAME=`dirname "$FILEPATH"`
	[ -d "$DIRNAME" ] || mkdir -p "$DIRNAME"

	# New file contents is on stdin.
	cat > "$FILEPATH" || {
		echo "$THISFILE: failed to write new file contents, trying to roll back." >&2
		git checkout --quiet -- "$FILEPATH" || {
			echo "$THISFILE: failed to run 'git checkout' after a write error." >&2
			exit 4
		}
		exit 3
	}

	# git-diff exits with 0 if the file is not in the repository.
	if ! git cat-file -e HEAD:"$FILEPATH" 2>/dev/null || ! git diff --quiet -- "$FILEPATH"; then
		git add -- "$FILEPATH"
		git commit --quiet --message="$COMMITMSG" ${AUTHOR:+--author="$AUTHOR"} -- "$FILEPATH"
		git_push_or_exit
	fi
}

# Both callScript() and GNU getopt support both short and long option formats.
# However, use of any getopt normally implies shift, which unsets the $@
# special parameter and makes it impossible or difficult to pass properly
# quoted option values to self via sudo. The getopts shell builtin (available
# in bash, dash and other shells) depends on its own state variables rather
# than shifting, but supports short options only.
#
# The only easy way to use any long options in this script would be to make
# the username a fixed argument, which could be tested before the getopt
# processing, but that would not look consistent. Hence this script uses
# getopts and short options for all arguments.

while getopts u:r:f:m:a: opt; do
	case "$opt" in
	u)
		SUDOUSER="$OPTARG"
		;;
	r)
		REPODIR="$OPTARG"
		;;
	f)
		FILEPATH="$OPTARG"
		;;
	m)
		COMMITMSG="$OPTARG"
		;;
	a)
		AUTHOR="$OPTARG"
		;;
	*)
		echo "$THISFILE: internal error parsing options!" >&2
		exit 3
	esac
done
: ${COMMITMSG:=update $FILEPATH}

assert_nonempty_option -u "$SUDOUSER"
[ `whoami` = "$SUDOUSER" ] || {
	sudo --non-interactive --set-home --user="$SUDOUSER" -- "$0" "$@"
	exit $?
}

assert_nonempty_option -r "$REPODIR"
assert_nonempty_option -f "$FILEPATH"
cd "$REPODIR"
git_pull_or_exit
git_commit_or_exit

exit 0
